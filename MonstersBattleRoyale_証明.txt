Monsters Battle Royaleのアルゴリズムが正しいことの証明
----------------------------------------------------------------------------------------

# 方針
N体のモンスターがランダムに減算し合ってモンスターがただ1体だけ生き残ったとき、最終的に全モンスターの体力のgcdが残ることを証明する

----------------------------------------------------------------------------------------

# 注意
記載を簡単にするため3変数で考える。
n変数でも同じ論理で証明可能。

----------------------------------------------------------------------------------------
# step. 0 表記の説明

a, b, cは整数とする。
a, b, cの最大公約数をgcd(a, b, c)と記すと、下記が成り立つ。

・a = gcd(a, b, c) * a0 ... (1)
・b = gcd(a, b, c) * b0 ... (2)
・c = gcd(a, b, c) * c0 ... (3)

ここで、a0, b0, c0の共通因数は無い。
※すなわち、互いに素(gcd(a, b, c) = 1)という意味。
※注意：互いに素は「このうちの２つの間の共通因数がない」という意味ではない。
    (例：6=2*3,15=3*5,10=2*5は互いに素だが、各2数には共通因数がある。)

まず、cがaに攻撃する。これをターン1とする。
各変数の添字は、ターン1における数であることを意味する。

・a’= gcd(a, b, c) * a1 = gcd(a, b, c) * (a0 - c0)
・b’= gcd(a, b, c) * b1 = gcd(a, b, c) * b0
・c’= gcd(a, b, c) * c1 = gcd(a, b, c) * c0
  ((3) - (1))


----------------------------------------------------------------------------------------
# step. 1 何かしらの攻撃後に、a, b, cのgcdが変化しないことを証明する

	----
	# step. 1-1
	a1, b1, c1の共通因数がないことを証明する。

	背理法を用いる。
	a1, b1, c1に共通因数があると仮定する。この共通因数をmとおく。
	すると、下記が成り立つ。

	・a1 = m * x
	・b1 = m * y
	・c1 = m * z
	  (x, y, zは整数)

	ここでa1 = a0 - c0 より、下記の通り変形できる。
	・a1 = a0 - c0 = m * x ... (1)
	・b1 = m * y           ... (2)
	・c1 = m * z           ... (3)

	・a0 = m * (x + z)
	・b0 = m * y
	・c0 = m * z
	  ((1) + (2))

	これは、a0, b0, c0に共通因数mが存在することを意味する。
	これは仮定に矛盾する。
	したがって、a1, b1, c1に共通因数はない ⇔ a1, b1, c1は互いに素
	----

"step. 1-1"より、下記が成り立つ。

・a’= gcd(a, b, c) * a1
・b’= gcd(a, b, c) * b1 = gcd(a, b, c) * b0
・c’= gcd(a, b, c) * c1 = gcd(a, b, c) * c0
上記において、a1, b1, c1に共通因数はない ⇔ a1, b1, c1は互いに素

したがって、下記が成り立つ。
gcd(a', b', c') = gcd(a', b, c) = gcd(a, b, c)
換言すると、任意のモンスターの攻撃の前後で、gcd(全モンスターの体力)は変化しない。
更に換言すると、任意のモンスターの攻撃に関係なく、各モンスターの体力は、gcd(全モンスターの体力)の倍数である。
⇔ gcd(全モンスターの体力) * m  (m ∈ {N})

【重要】したがって、モンスターが1体生き残ったとき、m = 1となる場合があれば、そのときがモンスターの体力が最小値であると確定する。


----------------------------------------------------------------------------------------
# step. 2
任意のモンスターの攻撃を繰り返すと、gcd(全モンスターの体力)のみ残ることを証明する。

各モンスターの体力を下記のとおり表す。
・a = gcd(a, b, c) * a0 ... (1)
・b = gcd(a, b, c) * b0 ... (2)
・c = gcd(a, b, c) * c0 ... (3)

このとき、2変数(2体のモンスター)において、下記は同値。
(α)「2体のモンスターがランダムに減算し合ってモンスターがただ1体だけ生き残ったとき、最終的に全モンスターの体力のgcdが残る」
(β)「aとbとcが互いに減算し合うと、2数が0となり、残った1数は必ずgcd(a, b, c)となる」
(γ)「a0とb0とc0が互いに減算し合うと、2数が0となり、残った1数は必ず1となる」
ここからは、(γ)を証明することで(α)を間接的に証明する。


	----
	## step. 2-1 「正の2整数a,bを互いに減算し合うと、片方が0になり、残りはgcd(a, b)となる」を証明する

	a = gcd(a, b) * a0    (1)
	b = gcd(a, b) * b0    (2)
	(a0,b0は互いに素)

	ここで、(1) - (b)を考える。
	a - b = gcd(a, b) * (a0 - b0)

		----
		# 補題 a0 - b0, b0が互いに素であることを証明する

		背理法を用いる。
		命題の否定である「a0 - b0, b0は互いに素ではない」を仮定する。

		この仮定は、下記と同値である。

		・a0 - b0 = m * x    (補題1)
		・b0 = m * y         (補題2)
		  (m, x, y ∈ {N})
		となる共通因数mが存在する。

		ここで、下記を考える。
		a0 = m * (x + y)     (補題1) + (補題2)
		これは、a0がmの倍数であることを意味する。
		すなわち、a0,b0に共通因数mが存在し、a0,b0は互いに素ではない。
		これは前提「a0,b0は互いに素である」に矛盾する。
		したがって、a0 - b0,b0は互いに素である。

		----

	補題より、a0 - b0は互いに素である。

	すなわち、iターン目に2数の片方(aiとする)がもう片方(biとする)を減じたとき、
	減じられた数ai - biと減じた数biは互いに素である。

	ここで、aとbを互いに減じ合うとき、減ぜられる数をx、減じる数をyとすると、下記が成り立つ。
	・差は必ず単調減少となる
	・減算は整数に閉じている
	・2数の残りが最小となる場合、減算x - yには、x>=yの関係がある
	  	ここで、x >= yをx > yとx = yに場合分けする。
	  	x > y ⇔ x - y > 0  この場合、差が正整数であるため、更に減じ合う(x - y, yが互いに素であることに注意)
	  	x = y ⇔ x - y = 0  この場合、片方が0となるため、減じ合うのは終了(減ずる前のx, yが互いに素であることに注意)

	上記より、片方が0となったとき、x,yが互いに素であることに着目する。
	x, yが互いに素である⇔gcd(x, y) = 1
	ここで、上記よりx=yであるから、下記が成り立つ。
	gcd(x, y) = gcd(x, x) = 1
	⇒ x = 1

	上記より、aiとbi(gcd(ai, bi) = 1)が減じ合い、片方が0となったとき、もう片方は必ず1となる。
	すなわち、(γ)は真である。

	----

"step. 2-1"より、2体のモンスターがランダムに減算し合ってモンスターがただ1体だけ生き残ったとき、最終的にgcd(全モンスターの体力)が残る。
したがって、iターン目にbがaの体力を0にしたとき、下記が成り立つ。
(aがbの体力を0にした際も同様に体力がそれぞれgcdと0になる。)
・a: gcd(a, b, c) * ai = gcd(a, b, c) * 0
・b: gcd(a, b, c) * bi = gcd(a, b, c) * gcd(a0, b0)
・c: gcd(a, b, c) * ci

同様に、jターン目(i < j)にcがbの体力を0にしたとき、下記が成り立つ。
・a: gcd(a, b, c) * aj = gcd(a, b, c) * 0
・b: gcd(a, b, c) * bj = gcd(a, b, c) * 0
・c: gcd(a, b, c) * cj = gcd(a, b, c) * gcd(gcd(a0 ,b0), c0)

	----
	## step. 2-2 「gcd(a, b, c) = gcd(gcd(a, b), c)」を証明する

	ここで、ある整数ai(ai>1)を素因数分解すると、下記のようにあらわせる。
	ai = Π_[j,k = 自然数], p[j]^(e[jk] * n[ij])  pは素数,eとnは自然数
	aiはe[ij]の集合と全単射の関係にあることに注意。(素因数分解の一意性)

	上記より、gcd(a, b, c)は、整数a,b,cの積集合とみなせる。(a,b,cを集合とみなしたものを各々A,B,Cと表す。)
	つまり、gcd(a, b, c) = ∩(A, B, C) ... (1)
	同様に、gcd(a, b) = ∩(A, B)       ... (2)

	ここで、∩(A, B, C, ...) = A ∩ B ∩ C ∩ ... であるから、
	∩(A, B, C) =  ((A ∩ B) ∩ C)     ... (3)

	(1), (2), (3)より、
	gcd(a, b, c) = gcd(gcd(a, b), c)

	※突き詰めると、積集合が原始帰納的関数であるか、とか、そういうことを証明する必要がありそう。この辺りは勉強不足で分からん。

	----

"step. 2-2"より、jターン目のa, b, cの体力は下記である。
・a: gcd(a, b, c) * aj = gcd(a, b, c) * 0
・b: gcd(a, b, c) * bj = gcd(a, b, c) * 0
・c: gcd(a, b, c) * cj = gcd(a, b, c) * gcd(gcd(a0 ,b0), c0) = gcd(a, b, c) * gcd(a0, b0, c0)

ここで、a0, b0, c0は互いに素であるから、gcd(a0, b0, c0) = 1となる。

したがって、モンスターcが残ったとき、c0が1となる場合が存在する。
・a: gcd(a, b, c) * aj = gcd(a, b, c) * 0
・b: gcd(a, b, c) * bj = gcd(a, b, c) * 0
・c: gcd(a, b, c) * cj = gcd(a, b, c) * 1

ここで、"step. 1"より、m = 1となる場合が存在すると分かった。
さらに、そのとき、生き残ったモンスターの体力は、最小値であるgcd(全モンスターの体力)である。
上記の証明はN変数に拡張可能であることは自明である。

了

----------------------------------------------------------------------------------------
おまけ
----------------------------------------------------------------------------------------
# ユークリッドの互除法の証明

下記を前提におく。
b = qa + r ⇔ b / a = q … r
  (a, b | a, b ∈ {N}, a != 0)

----
# step 1. 下記を証明する
d ∈ cd(a, r) ⇔ d ∈ cd(a, b)
  (d | d ∈ {N})

	----
	## step 1-1. 下記を証明する
	d ∈ cd(a, r) ⇒ d ∈ cd(a, b)
	  (d | d ∈ {N})

	下記のd0を考える。
	 (d0 | d0 ∈ {N} ∧ a mod d0 ≡ 0 ∧ r mod d0 ≡ 0)
	※ d0 ∈ cd(a, r)が成り立つ。	(1)
	※※ cd(a, r) ⇔ a,rの公約数

		----
		### 補題
		w, x, y ∈ {N}, x > y のとき、下記が成り立つ。

		x mod w ≡ 0 ⇒ xy mod w ≡ 0                            (補題1)
		※ wは、xの約数 ⇒ wはxyの約数

		x mod w ≡ 0 ∧ y mod w ≡ 0 ⇒ x + y mod w ≡ 0         (補題2)
		x - y mod w ≡ 0                                         (補題3)
		※ ⇔「wはxの約数、かつ、wはyの約数 ⇒ wはx + yの約数」
		※ ⇔「wはxの約数、かつ、wはyの約数 ⇒ wはx - yの約数」

		----

	(補題1)(補題2)より、下記が成り立つ。
	       qa mod d0 ≡ 0           (2)
	⇒ qa + r mod d0 ≡ 0           (3)

	ここで、(2)は、qa + r = b より、下記と同値。
	b mod d0 ≡ 0                   (4)

	(2)、(3)より、下記が成り立つ。
	d0 ∈ cd(a, b)

	したがって、下記が成り立つ。
	d0 ∈ cd(a, r) ⇒ d0 ∈ cd(a, b)
	  (d0 | d0 ∈ {N})              (I)

	----
	## step 1-2. 下記を証明する
	d1 ∈  cd(a, b) ⇒ d1 ∈ cd(a, r)
	  (d1 | d1 ∈ {N})

	下記のd1を考える。
	 (d1 | d1 ∈ {N} ∧ a mod d1 ≡ 0 ∧ b mod d1 ≡ 0)
	d1 ∈ cd(a, b)が成り立つ。      (5)

	(補題3)より、下記が成り立つ。
	       qa mod d1 ≡ 0
	⇒ b - qa mod d1 ≡ 0
	⇒      r mod d1 ≡ 0           (6)

	(5), (6)より、下記が成り立つ。
	d1　∈ cd(a, r)

	したがって、下記が成り立つ。
	d1 ∈ cd(a, b) ⇒ d1 ∈ cd(a, r)
	  (d1 | d1 ∈ {N})                (II)


	(I),(II)より、下記が成り立つ。
	d ∈  cd(a, r) ⇔ d ∈ cd(a, b)
	  (d | d ∈ {N})

	また、gcd(a, b) = max(cd(a, b))であるから、下記が成り立つ。
	gcd(a, r) = gcd(a, b)

	----

----
# step. 2 2数a,bが減算し合うと、片方の数(a or b)が0となり、残りの数(b or a)はgcd(a, b)となることを証明する

r = a mod bより、下記が成り立つ。
gcd(a, b) = gcd(a, r) = gcd(a, a mod b)

また、gcd(a, b)は交換則が成り立つ。

ここまでを総合すると、下記の等式が成り立つ
  gcd(a, b)
= gcd(a, b mod a)
= gcd(a, c)          c = b mod a とおいた。 a > cであることに注意。
= gcd(c, a mod c)
= gcd(c, d)          d = a mod c とおいた。 c > dであることに注意。
= …


上記の操作を繰り返すと、最終的に、割る数が割られる数を割り切ることになる。
※剰余が残り続けるパターンを最大限考えても、いつか必ず剰余が1になり、最終的に割り切れる展開となることに注意。
※※上記証明の中で証明済み。

上記の「割り切った」場面を考える。
gcd(x, y)において、yをxが割り切ったとする。
このとき、xはyの約数となる。

ここで、gcd(x, mx) (m | m ∈ {N})のとき、
gcd(x, mx) = xとなることは自明である。

したがって、上記をすべてまとめると、
gcd(a, b)を求めるには、下記を繰り返せば良いこととなる。
　1. a,bのうち、小さい方の数が0なら、大きな数が最大公約数となる
  2. a,bのうち、大きな数を小さな数で割り、余りを求める
　3. 余りを大きな数に上書きする


**ここまで**

